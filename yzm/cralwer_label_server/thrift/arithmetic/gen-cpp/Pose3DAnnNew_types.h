/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Pose3DAnnNew_TYPES_H
#define Pose3DAnnNew_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace ThriftPose3DAnn {

class Image;

class Vector3DInt;

class Vector3DFloat;

class Orientation;

class CameraInfo;

class GuessInfo;

class HumanPose3DInfo;

typedef struct _Image__isset {
  _Image__isset() : imgBin(false), width(false), height(false), channel(false) {}
  bool imgBin :1;
  bool width :1;
  bool height :1;
  bool channel :1;
} _Image__isset;

class Image : public virtual ::apache::thrift::TBase {
 public:

  Image(const Image&);
  Image& operator=(const Image&);
  Image() : imgBin(), width(0), height(0), channel(0) {
  }

  virtual ~Image() throw();
  std::string imgBin;
  int32_t width;
  int32_t height;
  int32_t channel;

  _Image__isset __isset;

  void __set_imgBin(const std::string& val);

  void __set_width(const int32_t val);

  void __set_height(const int32_t val);

  void __set_channel(const int32_t val);

  bool operator == (const Image & rhs) const
  {
    if (!(imgBin == rhs.imgBin))
      return false;
    if (!(width == rhs.width))
      return false;
    if (!(height == rhs.height))
      return false;
    if (!(channel == rhs.channel))
      return false;
    return true;
  }
  bool operator != (const Image &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Image & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Image &a, Image &b);

std::ostream& operator<<(std::ostream& out, const Image& obj);

typedef struct _Vector3DInt__isset {
  _Vector3DInt__isset() : x(false), y(false), z(false) {}
  bool x :1;
  bool y :1;
  bool z :1;
} _Vector3DInt__isset;

class Vector3DInt : public virtual ::apache::thrift::TBase {
 public:

  Vector3DInt(const Vector3DInt&);
  Vector3DInt& operator=(const Vector3DInt&);
  Vector3DInt() : x(0), y(0), z(0) {
  }

  virtual ~Vector3DInt() throw();
  int32_t x;
  int32_t y;
  int32_t z;

  _Vector3DInt__isset __isset;

  void __set_x(const int32_t val);

  void __set_y(const int32_t val);

  void __set_z(const int32_t val);

  bool operator == (const Vector3DInt & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    if (!(z == rhs.z))
      return false;
    return true;
  }
  bool operator != (const Vector3DInt &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Vector3DInt & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Vector3DInt &a, Vector3DInt &b);

std::ostream& operator<<(std::ostream& out, const Vector3DInt& obj);

typedef struct _Vector3DFloat__isset {
  _Vector3DFloat__isset() : x(false), y(false), z(false) {}
  bool x :1;
  bool y :1;
  bool z :1;
} _Vector3DFloat__isset;

class Vector3DFloat : public virtual ::apache::thrift::TBase {
 public:

  Vector3DFloat(const Vector3DFloat&);
  Vector3DFloat& operator=(const Vector3DFloat&);
  Vector3DFloat() : x(0), y(0), z(0) {
  }

  virtual ~Vector3DFloat() throw();
  double x;
  double y;
  double z;

  _Vector3DFloat__isset __isset;

  void __set_x(const double val);

  void __set_y(const double val);

  void __set_z(const double val);

  bool operator == (const Vector3DFloat & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    if (!(z == rhs.z))
      return false;
    return true;
  }
  bool operator != (const Vector3DFloat &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Vector3DFloat & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Vector3DFloat &a, Vector3DFloat &b);

std::ostream& operator<<(std::ostream& out, const Vector3DFloat& obj);

typedef struct _Orientation__isset {
  _Orientation__isset() : xAxis(false), yAxis(false), zAxis(false) {}
  bool xAxis :1;
  bool yAxis :1;
  bool zAxis :1;
} _Orientation__isset;

class Orientation : public virtual ::apache::thrift::TBase {
 public:

  Orientation(const Orientation&);
  Orientation& operator=(const Orientation&);
  Orientation() {
  }

  virtual ~Orientation() throw();
  Vector3DFloat xAxis;
  Vector3DFloat yAxis;
  Vector3DFloat zAxis;

  _Orientation__isset __isset;

  void __set_xAxis(const Vector3DFloat& val);

  void __set_yAxis(const Vector3DFloat& val);

  void __set_zAxis(const Vector3DFloat& val);

  bool operator == (const Orientation & rhs) const
  {
    if (!(xAxis == rhs.xAxis))
      return false;
    if (!(yAxis == rhs.yAxis))
      return false;
    if (!(zAxis == rhs.zAxis))
      return false;
    return true;
  }
  bool operator != (const Orientation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Orientation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Orientation &a, Orientation &b);

std::ostream& operator<<(std::ostream& out, const Orientation& obj);

typedef struct _CameraInfo__isset {
  _CameraInfo__isset() : camMatrix(false) {}
  bool camMatrix :1;
} _CameraInfo__isset;

class CameraInfo : public virtual ::apache::thrift::TBase {
 public:

  CameraInfo(const CameraInfo&);
  CameraInfo& operator=(const CameraInfo&);
  CameraInfo() {
  }

  virtual ~CameraInfo() throw();
  std::vector<double>  camMatrix;

  _CameraInfo__isset __isset;

  void __set_camMatrix(const std::vector<double> & val);

  bool operator == (const CameraInfo & rhs) const
  {
    if (!(camMatrix == rhs.camMatrix))
      return false;
    return true;
  }
  bool operator != (const CameraInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CameraInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CameraInfo &a, CameraInfo &b);

std::ostream& operator<<(std::ostream& out, const CameraInfo& obj);

typedef struct _GuessInfo__isset {
  _GuessInfo__isset() : guessOrien(false), guessJoints(false), camInfo(false), isSuccess(false) {}
  bool guessOrien :1;
  bool guessJoints :1;
  bool camInfo :1;
  bool isSuccess :1;
} _GuessInfo__isset;

class GuessInfo : public virtual ::apache::thrift::TBase {
 public:

  GuessInfo(const GuessInfo&);
  GuessInfo& operator=(const GuessInfo&);
  GuessInfo() : isSuccess(0) {
  }

  virtual ~GuessInfo() throw();
  std::vector<Orientation>  guessOrien;
  std::vector<Vector3DFloat>  guessJoints;
  CameraInfo camInfo;
  bool isSuccess;

  _GuessInfo__isset __isset;

  void __set_guessOrien(const std::vector<Orientation> & val);

  void __set_guessJoints(const std::vector<Vector3DFloat> & val);

  void __set_camInfo(const CameraInfo& val);

  void __set_isSuccess(const bool val);

  bool operator == (const GuessInfo & rhs) const
  {
    if (!(guessOrien == rhs.guessOrien))
      return false;
    if (!(guessJoints == rhs.guessJoints))
      return false;
    if (!(camInfo == rhs.camInfo))
      return false;
    if (!(isSuccess == rhs.isSuccess))
      return false;
    return true;
  }
  bool operator != (const GuessInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GuessInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GuessInfo &a, GuessInfo &b);

std::ostream& operator<<(std::ostream& out, const GuessInfo& obj);

typedef struct _HumanPose3DInfo__isset {
  _HumanPose3DInfo__isset() : joints(false), orien(false), camInfo(false) {}
  bool joints :1;
  bool orien :1;
  bool camInfo :1;
} _HumanPose3DInfo__isset;

class HumanPose3DInfo : public virtual ::apache::thrift::TBase {
 public:

  HumanPose3DInfo(const HumanPose3DInfo&);
  HumanPose3DInfo& operator=(const HumanPose3DInfo&);
  HumanPose3DInfo() {
  }

  virtual ~HumanPose3DInfo() throw();
  std::vector<Vector3DFloat>  joints;
  Orientation orien;
  CameraInfo camInfo;

  _HumanPose3DInfo__isset __isset;

  void __set_joints(const std::vector<Vector3DFloat> & val);

  void __set_orien(const Orientation& val);

  void __set_camInfo(const CameraInfo& val);

  bool operator == (const HumanPose3DInfo & rhs) const
  {
    if (!(joints == rhs.joints))
      return false;
    if (!(orien == rhs.orien))
      return false;
    if (!(camInfo == rhs.camInfo))
      return false;
    return true;
  }
  bool operator != (const HumanPose3DInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HumanPose3DInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HumanPose3DInfo &a, HumanPose3DInfo &b);

std::ostream& operator<<(std::ostream& out, const HumanPose3DInfo& obj);

} // namespace

#endif
